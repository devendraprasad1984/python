pip install abc1 future
abc1: abstract base classes creation

Creational design patterns: These design patterns are all about class instantiation. This pattern can be further divided into class-creation patterns and object-creational patterns. While class-creation patterns use inheritance effectively in the instantiation process, object-creation patterns use delegation effectively to get the job done.

Abstract Factory: Creates an instance of several families of classes related or dependent objects without directly specifying their concrete classes. This mechanism makes exchanging product families easy because the specific class of the factory object appears only once in the application - where it is instantiated. it is routinely implemented as a Singleton but they can also be implemented using Prototype. Abstract Factory, Builder, and Prototype can use Singleton in their implementation. Abstract Factory can be used as an alternative to Facade to hide platform-specific classes. Builder focuses on constructing a complex object step by step. Abstract Factory emphasizes a family of product objects (either simple or complex). Builder returns the product as a final step, but as far as the Abstract Factory is concerned, the product gets returned immediately

Builder: Separates object construction from its representation so that same construction process can create different representation also. e.g React.Component, react.createClass, ASCII, TeX, text widget etc., separate out the algo from creating the object and its represation. focus is on to the compolext aggregates. The Director just calls the command and builder do all complext bits and maintain objects states and return the final output only. Builder often builds the composite.

Factory Method: Creates an instance of several derived classes, lets a class defer instantiation to subclasses, virtual. eg a framework needs to standardise the architecture model for a range range of application but also it would let a specific application to define its own domain objects and their instantiation, like we due in angular or react. Factory Method is similar to Abstract Factory but without the emphasis on families. factory method is: a static method of a class that returns an object of that class' type. But unlike a constructor, the actual object it returns might be an instance of a subclass. Unlike a constructor, an existing object might be reused, instead of a new object created. The client is totally decoupled from the implementation details of derived classes. Polymorphic creation is now possible. The Factory Method defines an interface for creating objects, but lets subclasses decide which classes to instantiate. eg The class of toy (car, action figure, etc.) is determined by the mold.

Object Pool: Avoid expensive acquisition and release of resources by recycling objects that are no longer in use, used to manage the object caching, To achieve this, the Reusable Pool class is designed to be a singleton class, we don't want a process to have to wait for a particular object to be released, so the Object Pool also instantiates new objects as they are required, but must also implement a facility to clean up unused objects periodically. eg.reusablePool.getInstace.acquireReusable(), ReusablePool class is designed to be a singleton class. Its constructor(s) are private, which forces other classes to call its getInstance method to get the one instance of the  ReusablePool class. The Factory Method pattern can be used to encapsulate the creation logic for objects. However, it does not manage them after their creation, the object pool pattern keeps track of the objects it creates

Prototype: A fully initialized instance to be copied or cloned, Declare an abstract base class that specifies a pure virtual "clone" method, and, maintains a dictionary of all "cloneable" concrete derived classes. Any class that needs a "polymorphic constructor" capability: derives itself from the abstract base class, registers its prototypical instance, and implements the clone() operation. Abstract Factory classes are often implemented with Factory Methods, but they can be implemented using Prototype. Factory Method: creation through inheritance. Prototype: creation through delegation. Designs that make heavy use of the Composite and Decorator patterns often can benefit from Prototype as well. Prototype co-opts one instance of a class for use as a breeder of all future instances. Prototypes are useful when object initialization is expensive, and you anticipate few variations on the initialization parameters. In this context, Prototype can avoid expensive "creation from scratch", and support cheap cloning of a pre-initialized prototype. eg a heavy loaded file from storage into object/application context, you may not want to reloaded again, if it has all config and data related to further operations. Prototype is unique among the other creational patterns in that it doesn't require a class – only an object. Object-oriented languages like Self and Omega that do away with classes completely rely on prototypes for creating new objects.

Singleton: A class of which only a single instance can exist and provide a global point of access to it, lazy initialization and global access are necessary, The "static member function accessor" approach will not support subclassing of the Singleton class, The Singleton pattern can be extended to support access to an application-specific number of instances, Abstract Factory, Builder, and Prototype can use Singleton in their implementation, Facades are often implemented as singleton as only one Facade object in app is required, state objects are singleton, the advantage over global variables is that we can control the number of instances, A Singleton is, for intents and purposes, a global variable. The Singleton does not do away with the global; it merely renames it, its not a problem solver for problems that can arise using global variables.


Structural design patterns: These design patterns are all about Class and Object composition. Structural class-creation patterns use inheritance to compose interfaces. Structural object-patterns define ways to compose objects to obtain new functionality.
Adapter: Match interfaces of different classes, Adapter lets classes work together that couldn't otherwise because of incompatible interfaces, wrap an existing class with new interface, impedance match an old system with new system, adapter solves problem e.g. An "off the shelf" component offers compelling functionality that you would like to reuse, but its "view of the world" is not compatible with the philosophy and architecture of the  system currently being developed, acts sort of common interface among incompatible old systems and provide common accessible mode to communicate with those different components, Adapter is about creating an intermediary abstraction that translates, or maps, the old component to the new system. Clients call methods on the Adapter object which redirects them into calls to the legacy component. This strategy can be implemented either with inheritance or with aggregation, It provides a different or translated view of that class, Adapter makes things work after they're designed; Bridge makes them work before they are, Bridge is designed up-front to let the abstraction and the implementation vary independently. Adapter is retrofitted to make unrelated classes work together, Adapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface, Adapter is meant to change the interface of an existing object. Decorator enhances another object without changing its interface. Decorator is thus more transparent to the application than an adapter is. As a consequence, Decorator supports recursive composition, which isn't possible with pure Adapters., Facade defines a new interface, whereas Adapter reuses an old interface, Adapter is retrofitted to make unrelated classes work together.

Bridge: Separates an object’s interface from its implementation,Publish interface in an inheritance hierarchy, and bury implementation in its own inheritance hierarchy, Beyond encapsulation, to insulation. problem: "Hardening of the software arteries" has occurred by using subclassing of an abstract base class to provide alternative implementations. This locks in compile-time binding between interface and implementation. The abstraction and implementation cannot be independently extended or composed. eg thread schedular acts as a bridge, The Bridge design pattern proposes refactoring this exponentially explosive inheritance hierarchy into two orthogonal hierarchies – one for platform-independent abstractions, and the other for platform-dependent implementations, The interface object is the "handle" known and used by the client; while the implementation object, or "body", is safely encapsulated to ensure that it may continue to evolve, or be entirely replaced (or shared at run-time. use bridge pattern when you see (you want run-time binding of the implementation, you have a proliferation of classes resulting from a coupled interface and numerous implementations, you want to share an implementation among multiple objects,you need to map orthogonal class hierarchies.). The Client doesn't want to deal with platform-dependent details. The Bridge pattern encapsulates this complexity behind an abstraction "wrapper". Decide if two orthogonal dimensions exist in the domain. These independent concepts could be: abstraction/platform, or domain/infrastructure, or front-end/back-end, or interface/implementation, Design the separation of concerns: what does the client want, and what do the platforms provide. Design a platform-oriented interface that is minimal, necessary, and sufficient. Its goal is to decouple the abstraction from the platform. Define a derived class of that interface for each platform. State, Strategy, Bridge (and to some degree Adapter) have similar solution structures. They all share elements of the "handle/body" idiom. They differ in intent - that is, they solve different problems

Composite: A tree structure of simple and composite objects, Recursive composition, 1-to-many "has a" up the "is a" hierarchy, Use this pattern whenever you have "composites that contain components, each of which could be a composite". addChild(), removeChild(), eg manipulating DOM elements, Menus that contain menu items, each of which could be a menu., Directories that contain files, each of which could be a directory, Containers that contain Elements, each of which could be a Container, Composite and Decorator have similar structure diagrams, reflecting the fact that both rely on recursive composition to organize an open-ended number of objects., Composite can be traversed with Iterator. Visitor can apply an operation over a Composite. Composite could use Chain of Responsibility to let components access global properties through their parent. It could also use Decorator to override these properties on parts of the composition. It could use Observer to tie one object structure to another and State to let a component change its behavior as its state changes. Decorator is designed to let you add responsibilities to objects without subclassing. Composite's focus is not on embellishment but on representation. These intents are distinct but complementary. Consequently, Composite and Decorator are often used in concert.

Decorator: Add responsibilities to objects dynamically

Facade: A single class that represents an entire subsystem

Flyweight: A fine-grained instance used for efficient sharing

Private Class Data: Restricts accessor/mutator access

Proxy: An object representing another object


Behavioral design patterns: These design patterns are all about Class's objects communication. Behavioral patterns are those patterns that are most specifically concerned with communication between objects.
Chain of responsibility: A way of passing a request between a chain of objects
Command: Encapsulate a command request as an object

Interpreter: A way to include language elements in a program

Iterator: Sequentially access the elements of a collection

Mediator: Defines simplified communication between classes

Memento: Capture and restore an object's internal state

Null Object: Designed to act as a default value of an object

Observer: A way of notifying change to a number of classes

State: Alter an object's behavior when its state changes

Strategy: Encapsulates an algorithm inside a class

Template method: Defer the exact steps of an algorithm to a subclass

Visitor: Defines a new operation to a class without change